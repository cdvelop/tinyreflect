# Tiny Reflect
<!-- START_SECTION:BADGES_SECTION -->
<a href="docs/img/badges.svg"><img src="docs/img/badges.svg" alt="Project Badges" title="Generated by badges package from github.com/cdvelop/devscripts"></a>
<!-- END_SECTION:BADGES_SECTION -->


Minimal Go reflect package from reflectlite, WebAssembly and TinyGo destination.

It provides a **global function API** similar to Go's standard reflect package, optimized for performance in resource-constrained environments.


## Why?

**Go's WebAssembly potential is incredible**, but traditional applications face a critical challenge: **massive binary sizes** that make web deployment impractical.

### The Problem
Every Go project needs reflection capabilities for JSON operations, struct field access, and dynamic type handling - but importing the standard library `reflect` package creates significant binary bloat that hurts:

- üåê **Web app performance** - Slow loading times and poor user experience
- üì± **Edge deployment** - Resource constraints on small devices  
- üöÄ **Distribution efficiency** - Large binaries for simple operations

### The Solution
TinyReflect replaces the standard library reflect package with **ultra-minimal, focused implementations** that deliver:

- üèÜ **Dramatically smaller binaries** - Significant size reduction for WebAssembly through maximum code reuse
- ‚úÖ **Full TinyGo compatibility** - 100% compatible, no compilation issues or warnings ([see details](docs/TINYGO_COMPATIBILITY.md))
- üéØ **Predictable performance** - No hidden allocations or overhead
- üîß **Minimal API** - Only essential operations for basic JSON-like data handling
- üåç **Multilingual error handling** - Integrated with tinystring's error system
- ‚ôªÔ∏è **Maximum code reuse** - Leverages tinystring's type detection to minimize duplication
- üìö **Go standard library API** - Global functions like Go's reflect package

### Supported Types (Minimalist Approach)
TinyReflect **intentionally** supports only a minimal set of types to keep binary size small:

**‚úÖ Supported Types:**
- **Basic types**: `string`, `bool`
- **All numeric types**: `int`, `int8`, `int16`, `int32`, `int64`, `uint`, `uint8`, `uint16`, `uint32`, `uint64`, `float32`, `float64`
- **All basic slices**: `[]string`, `[]bool`, `[]byte`, `[]int`, `[]int8`, `[]int16`, `[]int32`, `[]int64`, `[]uint`, `[]uint8`, `[]uint16`, `[]uint32`, `[]uint64`, `[]float32`, `[]float64`
- **Structs**: Only with supported field types
- **Struct slices**: `[]struct{...}` where all fields are supported types
- **Maps**: `map[K]V` where K and V are supported types only
- **Map slices**: `[]map[K]V` where K and V are supported types only
- **Pointers**: Only to supported types above

**‚ùå Unsupported Types:**
- `any`, `chan`, `func`
- `complex64`, `complex128`
- `uintptr`, `unsafe.Pointer` (used internally only)
- Arrays (different from slices)
- Nested complex types beyond supported scope

This focused approach ensures minimal code size while covering the most common JSON-like data operations including simple structs.



## API Usage

TinyReflect provides global functions similar to Go's standard reflect package.

```go
import "github.com/cdvelop/tinyreflect"

type User struct {
    Name string
    Age  int
}

// IMPORTANT: For struct name resolution, implement StructNamer interface
func (User) StructName() string {
    return "User"
}

u := User{"Alice", 42}

// Use global functions to get a reflected Value
v := tinyreflect.ValueOf(u)

// Get the reflected type
t := tinyreflect.TypeOf(u)

// Get the struct name (requires StructNamer interface)
name := t.Name() // Returns "User" if StructNamer is implemented, "struct" otherwise

// Iterate fields and get name and value
num, _ := t.NumField()
for i := 0; i < num; i++ {
    fieldName, _ := t.NameByIndex(i)
    field, _ := v.Field(i)
    value, _ := field.Interface()
    // fieldName: field name, value: field value
}

// Unique type identifier
id := t.StructID()

// Check if a field value is zero (useful for partial updates)
field, _ := v.Field(0)
if field.IsZero() {
    // Field has zero value
}
```

### Minimal public API

#### Global Functions
- `TypeOf(i any) *Type` ‚Äî Returns the reflection Type that represents the dynamic type of i.
- `ValueOf(i any) Value` ‚Äî Returns a new Value initialized to the concrete value stored in the interface i.
- `Indirect(v Value) Value` ‚Äî Returns the value that a pointer `v` points to.
- `NewValue(typ *Type) Value` ‚Äî Returns a `Value` representing a pointer to a new zero value for `typ`.
- `MakeSlice(typ *Type, len, cap int) (Value, error)` ‚Äî Creates a new zero-initialized slice value.

#### Value Methods
- `Value.Type() *Type` ‚Äî Get the reflected type.
- `Value.Field(i int) (Value, error)` ‚Äî Get the i-th field of a struct value.
- `Value.NumField() (int, error)` ‚Äî Number of fields in a struct value.
- `Value.Kind() Kind` ‚Äî Get the kind of the value.
- `Value.CanAddr() bool` ‚Äî Reports whether the value's address can be obtained.
- `Value.IsZero() bool` ‚Äî Reports whether v is the zero value for its type.
- `Value.Elem() (Value, error)` ‚Äî Returns the value that the pointer points to.
- `Value.String() string` ‚Äî Returns the string representation of the value.
- `Value.Int() (int64, error)` ‚Äî Returns the value as int64.
- `Value.Uint() (uint64, error)` ‚Äî Returns the value as uint64.
- `Value.Float() (float64, error)` ‚Äî Returns the value as float64.
- `Value.Bool() (bool, error)` ‚Äî Returns the value as bool.
- `Value.InterfaceZeroAlloc(target *any)` ‚Äî Sets value to target pointer without boxing.

#### Type Methods
- `Type.Name() string` ‚Äî Get type name (requires StructNamer for structs).
- `Type.NumField() (int, error)` ‚Äî Number of fields in a struct.
- `Type.NameByIndex(i int) (string, error)` ‚Äî Name of the i-th field.
- `Type.Field(i int) (StructField, error)` ‚Äî Info about the i-th field.
- `Type.Kind() Kind` ‚Äî Base type (struct, int, string, etc).
- `Type.StructID() uint32` ‚Äî Unique identifier for the struct type.

> No functions related to methods, interfaces, or advanced reflection are exposed. The API is deliberately minimal and robust against misuse.


## Important: Struct Name Resolution in TinyGo

**TinyReflect requires struct types to implement the `StructNamer` interface to provide their name.**

```go
type StructNamer interface {
    StructName() string
}
```

### Why This Limitation Exists

TinyGo removes type metadata (including struct names) from compiled binaries to reduce size. Unlike standard Go, runtime type name resolution is not available. To work around this:

1. **With StructNamer**: `Type.Name()` returns the custom name
2. **Without StructNamer**: `Type.Name()` returns `"struct"`
3. **Non-struct types**: `Type.Name()` returns the kind name (`"int"`, `"string"`, etc.)

### Example Implementation

```go
import (
    "fmt"
    "github.com/cdvelop/tinyreflect"
)

type Customer struct {
    ID   int
    Name string
}

// Required for name resolution in TinyGo
func (Customer) StructName() string {
    return "customer"
}

// Usage
c := Customer{ID: 1, Name: "Alice"}
typ := tinyreflect.TypeOf(c)
fmt.Println(typ.Name()) // Output: "customer"

// Without StructNamer interface:
type Product struct {
    Title string
    Price float64
}
// No StructName() method defined

p := Product{Title: "Book", Price: 15.99}
typ2 := tinyreflect.TypeOf(p)
fmt.Println(typ2.Name()) // Output: "struct"
```

This approach ensures TinyGo compatibility while allowing applications that need struct names to opt-in via interface implementation.


## [Performance](docs/BENCH.md)




---
## [Contributing](https://github.com/cdvelop/cdvelop/blob/main/CONTRIBUTING.md)