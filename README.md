# tinyreflect
<!-- START_SECTION:BADGES_SECTION -->
<a href="docs/img/badges.svg"><img src="docs/img/badges.svg" alt="Project Badges" title="Generated by badges.sh from github.com/cdvelop/devscripts"></a>
<!-- END_SECTION:BADGES_SECTION -->


Minimal Go reflect package from reflectlite, WebAssembly and TinyGo destination


## Why TinyReflect?

**Go's WebAssembly potential is incredible**, but traditional applications face a critical challenge: **massive binary sizes** that make web deployment impractical.

### The Problem
Every Go project needs reflection capabilities for JSON operations, struct field access, and dynamic type handling - but importing the standard library `reflect` package creates significant binary bloat that hurts:

- üåê **Web app performance** - Slow loading times and poor user experience
- üì± **Edge deployment** - Resource constraints on small devices  
- üöÄ **Distribution efficiency** - Large binaries for simple operations

### The Solution
TinyReflect replaces the standard library reflect package with **ultra-minimal, focused implementations** that deliver:

- üèÜ **Dramatically smaller binaries** - Significant size reduction for WebAssembly through maximum code reuse
- ‚úÖ **Full TinyGo compatibility** - No compilation issues or warnings
- üéØ **Predictable performance** - No hidden allocations or overhead
- üîß **Minimal API** - Only essential operations for basic JSON-like data handling
- üåç **Multilingual error handling** - Integrated with tinystring's error system
- ‚ôªÔ∏è **Maximum code reuse** - Leverages tinystring's type detection to minimize duplication

### Supported Types (Minimalist Approach)
TinyReflect **intentionally** supports only a minimal set of types to keep binary size small:

**‚úÖ Supported Types:**
- **Basic types**: `string`, `bool`
- **All numeric types**: `int`, `int8`, `int16`, `int32`, `int64`, `uint`, `uint8`, `uint16`, `uint32`, `uint64`, `float32`, `float64`
- **All basic slices**: `[]string`, `[]bool`, `[]byte`, `[]int`, `[]int8`, `[]int16`, `[]int32`, `[]int64`, `[]uint`, `[]uint8`, `[]uint16`, `[]uint32`, `[]uint64`, `[]float32`, `[]float64`
- **Structs**: Only with supported field types
- **Struct slices**: `[]struct{...}` where all fields are supported types
- **Maps**: `map[K]V` where K and V are supported types only
- **Map slices**: `[]map[K]V` where K and V are supported types only
- **Pointers**: Only to supported types above

**‚ùå Unsupported Types:**
- `interface{}`, `chan`, `func`
- `complex64`, `complex128`
- `uintptr`, `unsafe.Pointer` (used internally only)
- Arrays (different from slices)
- Nested complex types beyond supported scope

This focused approach ensures minimal code size while covering the most common JSON-like data operations including simple structs.

type User struct {
u := User{"Alice", 42}
v := tinyreflect.ValueOf(u)
t := v.Type()
id := t.StructID()
## Minimal API usage

```go
import "github.com/cdvelop/tinyreflect"

type User struct {
    Name string
    Age  int
}

u := User{"Alice", 42}
v := tinyreflect.ValueOf(u)
t := v.Type()

// Iterate fields and get name and value
num, _ := t.NumField()
for i := 0; i < num; i++ {
    name, _ := t.NameByIndex(i)
    field, _ := v.Field(i)
    value, _ := field.Interface()
    // name: field name, value: field value
}

// Unique type identifier (alternative to struct name)
id := t.StructID()
```

### Minimal public API

- `ValueOf(any) Value` ‚Äî Create a reflected value.
- `Value.Type() *Type` ‚Äî Get the reflected type.
- `Value.Field(i int) (Value, error)` ‚Äî Get the i-th field of a struct value.
- `Value.Interface() (any, error)` ‚Äî Get the value as interface{}.
- `Type.NumField() (int, error)` ‚Äî Number of fields in a struct.
- `Type.NameByIndex(i int) (string, error)` ‚Äî Name of the i-th field.
- `Type.Field(i int) (StructField, error)` ‚Äî Info about the i-th field.
- `Type.Kind() Kind` ‚Äî Base type (struct, int, string, etc).
- `Type.StructID() uint32` ‚Äî Unique identifier for the struct type.

> No functions related to methods, interfaces, struct names, or advanced reflection are exposed. The API is deliberately minimal and robust against misuse.


## Important: Reflection Limitations in TinyGo

> **Note:** TinyReflect cannot obtain the textual name of a struct (like "Customer") in TinyGo, because TinyGo removes these metadata from the binary. See [docs/LIMITATIONS_REFLECT_TINYGO.md](docs/LIMITATIONS_REFLECT_TINYGO.md) for a detailed technical explanation and recommended alternatives.

---
## [Contributing](docs/CONTRIBUTING.md)